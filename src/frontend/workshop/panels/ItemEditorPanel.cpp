#include "../WorkshopScreen.hpp"

#include "../../../items/ItemDef.hpp"
#include "../IncludeCommons.hpp"
#include "../WorkshopSerializer.hpp"

void workshop::WorkShopScreen::createItemEditor(ItemDef& item) {
	createPanel([this, &item]() {
		std::string actualName(item.name.substr(currentPackId.size() + 1));
		fs::path filePath(currentPack.folder / ContentPack::ITEMS_FOLDER / std::string(actualName + ".json"));
		const bool hasFile = fs::is_regular_file(filePath);

		gui::Panel& panel = *new gui::Panel(glm::vec2(settings.itemEditorWidth));
		if (!hasFile) {
			gui::Label& label = *new gui::Label(L"Autogenerated item from existing block\nCreate file to edit item propreties");
			label.setTextWrapping(true);
			label.setMultiline(true);
			label.setSize(panel.getSize());
			panel += label;

			panel += new gui::Button(L"Create file", glm::vec4(10.f), [this, &item, actualName](gui::GUI*) {
				saveItem(item, currentPack.folder, actualName);
				createItemEditor(item);
			});
			return std::ref(panel);
		}
		panel += new gui::Label(actualName);

		panel += new gui::Label("Caption");
		createTextBox(panel, item.caption, L"Example item");

		panel += new gui::Label(L"Stack size:");
		panel += createNumTextBox<uint32_t>(item.stackSize, L"1", 1, 64);
		createEmissionPanel(panel, item.emission);

		panel += new gui::Label(L"Icon");
		gui::Panel& textureIco = *new gui::Panel(glm::vec2(panel.getSize().x, 35.f));
		createTexturesPanel(textureIco, 35.f, item.icon, item.iconType);
		panel += textureIco;

		const wchar_t* const iconTypes[] = { L"none", L"sprite", L"block" };
		gui::Button* button = new gui::Button(L"Icon type: " + std::wstring(iconTypes[static_cast<unsigned int>(item.iconType)]), glm::vec4(10.f), gui::onaction());
		button->listenAction([this, button, iconTypes, &item, &textureIco, &panel](gui::GUI*) {
			switch (item.iconType) {
				case item_icon_type::block:
					item.iconType = item_icon_type::none;
					item.icon = "core:air";
					break;
				case item_icon_type::none:
					item.iconType = item_icon_type::sprite;
					item.icon = "blocks:notfound";
					break;
				case item_icon_type::sprite:
					item.iconType = item_icon_type::block;
					item.icon = "core:air";
					break;
			}
			removePanels(3);
			button->setText(L"Icon type: " + std::wstring(iconTypes[static_cast<unsigned int>(item.iconType)]));
			clearRemoveList(textureIco);
			createTexturesPanel(textureIco, 35.f, item.icon, item.iconType);
			textureIco.cropToContent();
		});
		panel += button;

		panel += new gui::Label(L"Placing block");
		gui::Panel& placingBlockPanel = *new gui::Panel(glm::vec2(panel.getSize().x, 35.f));
		createTexturesPanel(placingBlockPanel, 35.f, item.placingBlock, item_icon_type::block);
		panel += placingBlockPanel;

		panel += new gui::Label("Script file");
		button = new gui::Button(util::str2wstr_utf8(getScriptName(currentPack, item.scriptName)), glm::vec4(10.f), gui::onaction());
		button->listenAction([this, &panel, button, actualName, &item](gui::GUI*) {
			createScriptList(5, panel.calcPos().x + panel.getSize().x, [this, button, actualName, &item](const std::string& string) {
				removePanels(5);
				std::string scriptName(getScriptName(currentPack, string));
				item.scriptName = (scriptName == NOT_SET ? (getScriptName(currentPack, actualName) == NOT_SET ? actualName : "") : scriptName);
				button->setText(util::str2wstr_utf8(scriptName));
			});
		});
		panel += button;

		panel += new gui::Button(L"Save", glm::vec4(10.f), [this, actualName, &item](gui::GUI*) {
			itemsList[actualName] = stringify(item, actualName, false);
			saveItem(item, currentPack.folder, actualName);
		});
		if (!item.generated) {
			panel += new gui::Button(L"Rename", glm::vec4(10.f), [this, actualName](gui::GUI*) {
				createDefActionPanel(DefAction::RENAME, DefType::ITEM, actualName);
			});
		}
		panel += new gui::Button(L"Delete", glm::vec4(10.f), [this, &item, actualName](gui::GUI*) {
			createDefActionPanel(DefAction::DELETE, DefType::ITEM, actualName, !item.generated);
		});

		return std::ref(panel);
	}, 2);
}